1.一个进程包含多个线程，多个线程共享一个进程的资源。
2.一个进程表示一个应用程序，比如word，execel等等
3.所以我们的操作系统是多进程多线程多任务的操作系统
4.线程属性：
  1.编号 ,类型为long ,用于标识不同的线程，不同的线程有不同的编号,只读属性
  
  2.名称，类型为string,用于区分不同的线程，默认格式为 Thread-线程编号，不是只读属性
  
  3.类别(daemon)　类型为boolean 如果为true表示守护线程，否则为用户线程
  
  4.优先级(priority) 类型为int，1-10，默认为5，对于具体的一个线程而言，其优先级的默认值与父线程的优先级相等.
  
  线程的优先级：本质上只是一个给线程调度器的提示信息，以便于线程调度器决定优先调度哪些线程运行，它并不能保证线程按照其优先
  级高低的顺序运行，java的线程优先级使用不当或者滥用可能导致某些线程永远无法执行到，即产生了线程饥饿(Thread Starvation),因此线程
  的优先级并不是设置的越高越好，一般情况下使用普通优先级即可。即不必设置线程的优先级属性。
  
5.线程分为：守护线程和用户线程。
  
6.java语言中， long和double以外的任何类型的变量写操作都是原子性操作，即对基础类型(long/double除外,包括byte,boolean
  
     ,short,char,float和int)变量和引用变量的写操作都是原子的。
7.多线程产生的问题：原子性(利用锁或者CAS(比较交互，硬件锁)实现原子性)，可见性，有序性
  
  1.原子性(利用锁(软件锁)或者CAS(比较交互，硬件锁)实现原子性)，原子操作多线程环境下个一个概念，他是针对
  共享变量的操作而言，包含两层含义，
   a.访问(读，写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生,
   即其他线程不会看到该操作执行了部分中间结果
   b.访问同一组共享变量的原子操作时不能被交错的。
   
   在java语言中 ,long和double以外的任何类型变量，包括引用变量的写操作都是原子操作，可以在long和double前面加入volatile关键字， 但是
   
   volatile只保证写的原子性，
   java中对任何变量的读操作都是原子性的，
   
   
  
8.脏读：读到过期的数据，丢失更新：某些线程所作的更新被其他线程所作的更新覆盖
  
9.并发，往往是带有部分串行的并发，而并发的极致就是并行，并发就是在一段时间内以交替的方式
  去完成多个任务，而并行就是以齐头并进的方式去完成多个任务，
  
10.多线程编程的实质就是将任务以串行改为并发(或者并行)，那么我们称这个任务是可以并发的，但是有的任务则必须是串行的， 比如读取一个文件。
  
11.排他锁Exclusive 也称为互斥锁Mutex  读写锁被看成是Exclusive的一种相对改进。
  
12.java锁的分类， 内部锁(synchronize，一种排他锁，保证原子性，可见性，有序性)和显示锁 Lock接口(ReentrantLock重入锁)

13.临界区：线程在获取锁之后和释放锁之前这段时间内锁执行的代码称为临界区，因此共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。

14.锁就是将多个线程对共享数据的并发访问转换为串行访问。即一个共享数据一次只能被一个线程访问，该线程访问结束后其他的线程才能对其进行访问。
  
15.锁的作用包含共享数据以实现线程安全，包括保证原子性，可见性，有序性。
    锁是通过互斥保证原子性，可见性，有序性。

16.公平锁和非公平锁,  内部锁为非公平锁，显示锁(ReentrantLock)支持公平和非公平锁
   默认 为非公平锁， 因为非公平锁效率高，

17.读写锁(read/writer lock)是一种改进型锁，也称为共享排他锁，
   特点：
    1.多个线程可以同时读(只读)共享变量
    2.一次只允许一个线程对共享变量进行更新(先读取后更新)
    3.任何线程在读的时候，其他线程无法进行更新
    4.一个线程在更新变量的时候，其他线程都无法访问该变量
    
    private final ReadWriterLock rwl = new ReentrantReaderWriter();
    private final Lock reader = rwl.readLock();
    private final local writer = rwl.writerLock();
    
  应用场景：满足以下两个条件
    1. 只读比写操作频繁，
    2. 读线程持有锁的时间比较长
    
18.volatile 轻量级锁
    保证可见性和有序性，与锁不同的是， 锁保证原子性和排他性，而volatile只保证原子性，但是volatile
    不会引起上下文切换， 所以被称为轻量级锁。
    
  作用：保障有序性，可见性，保障long/double型变量读写的原子性。
  java语言中对long和double类型变量以外任何类型变量写操作都是原子性的。

  对数组元素的读， 写若要保证触发volatile关键字的作用，则可以采用volatile，可以采用AutomicIntegerArray,AutomicLongArray,AutomicReferenceArray

  volatile的开销，volatile的变量读写不会涉及到上下文切换，因此比锁的开销要小，

    锁的开销涉及到：锁的申请，释放，上下文切换，

    但是volatile的开销比普通变量要高一些，
   
 volatile的应用场景：  volatile除了保证数据的读，写操作的原子性(long/double除外)，典型场景还有如下：
  
 19.CAS只保障共享变量更新操作的原子性， 不保障可见性 

  volatile只保证可见性， 不保证原子性。
  
20，原子操作工具，原子变量类 Atomics
  atomic是基于CAS实现的能保证对共享变量进行 reader-modify-writer更新操作的原子性和可见性的
  一组工具，
  原子变量类相当于基于CAS实现的增强型voloatile变量。
  
  原子变量类有12个，如下分类
  
  基础类     AtomicInteger AtomicLong AtomicBoolean
  数组类    AtomicIntegerArray AtomicLongArray AtomicReferenceArray
 字段更新器 AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater
 引用型 AtomicReference AtomicStampedReference AtomicMarkableReference
   
 


    

  
  
  
  
  