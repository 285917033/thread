1.一个进程包含多个线程，多个线程共享一个进程的资源。
2.一个进程表示一个应用程序，比如word，execel等等
3.所以我们的操作系统是多进程多线程多任务的操作系统
4.线程属性：
  1.编号 ,类型为long ,用于标识不同的线程，不同的线程有不同的编号,只读属性
  
  2.名称，类型为string,用于区分不同的线程，默认格式为 Thread-线程编号，不是只读属性
  
  3.类别(daemon)　类型为boolean 如果为true表示守护线程，否则为用户线程
  
  4.优先级(priority) 类型为int，1-10，默认为5，对于具体的一个线程而言，其优先级的默认值与父线程的优先级相等.
  
  线程的优先级：本质上只是一个给线程调度器的提示信息，以便于线程调度器决定优先调度哪些线程运行，它并不能保证线程按照其优先
  级高低的顺序运行，java的线程优先级使用不当或者滥用可能导致某些线程永远无法执行到，即产生了线程饥饿(Thread Starvation),因此线程
  的优先级并不是设置的越高越好，一般情况下使用普通优先级即可。即不必设置线程的优先级属性。
  
5.线程分为：守护线程和用户线程。
  
6.java语言中， long和double以外的任何类型的变量写操作都是原子性操作，即对基础类型(long/double除外,包括byte,boolean
  
     ,short,char,float和int)变量和引用变量的写操作都是原子的。
7.多线程产生的问题：原子性(利用锁或者CAS(比较交互，硬件锁)实现原子性)，可见性，有序性
  
  1.原子性(利用锁(软件锁)或者CAS(比较交互，硬件锁)实现原子性)，原子操作多线程环境下个一个概念，他是针对
  共享变量的操作而言，包含两层含义，
   a.访问(读，写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生,
   即其他线程不会看到该操作执行了部分中间结果
   b.访问同一组共享变量的原子操作时不能被交错的。
   
   在java语言中 ,long和double以外的任何类型变量，包括引用变量的写操作都是原子操作，可以在long和double前面加入volatile关键字， 但是
   
   volatile只保证写的原子性，
   java中对任何变量的读操作都是原子性的，
   
   
  
8.脏读：读到过期的数据，丢失更新：某些线程所作的更新被其他线程所作的更新覆盖
  
9.并发，往往是带有部分串行的并发，而并发的极致就是并行，并发就是在一段时间内以交替的方式
  去完成多个任务，而并行就是以齐头并进的方式去完成多个任务，
  
10.多线程编程的实质就是将任务以串行改为并发(或者并行)，那么我们称这个任务是可以并发的，但是有的任务则必须是串行的， 比如读取一个文件。
  
11.排他锁Exclusive 也称为互斥锁Mutex  读写锁被看成是Exclusive的一种相对改进。
  
12.java锁的分类， 内部锁(synchronize，一种排他锁，保证原子性，可见性，有序性)和显示锁 Lock接口(ReentrantLock重入锁)

13.临界区：线程在获取锁之后和释放锁之前这段时间内锁执行的代码称为临界区，因此共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。

14.锁就是将多个线程对共享数据的并发访问转换为串行访问。即一个共享数据一次只能被一个线程访问，该线程访问结束后其他的线程才能对其进行访问。
  
15.锁的作用包含共享数据以实现线程安全，包括保证原子性，可见性，有序性。
    锁是通过互斥保证原子性，可见性，有序性。

16.公平锁和非公平锁,  内部锁为非公平锁，显示锁(ReentrantLock)支持公平和非公平锁
   默认 为非公平锁， 因为非公平锁效率高，

17.读写锁(read/writer lock)是一种改进型锁，也称为共享排他锁，
   特点：
    1.多个线程可以同时读(只读)共享变量
    2.一次只允许一个线程对共享变量进行更新(先读取后更新)
    3.任何线程在读的时候，其他线程无法进行更新
    4.一个线程在更新变量的时候，其他线程都无法访问该变量
    
    private final ReadWriterLock rwl = new ReentrantReaderWriter();
    private final Lock reader = rwl.readLock();
    private final local writer = rwl.writerLock();
    
  应用场景：满足以下两个条件
    1. 只读比写操作频繁，
    2. 读线程持有锁的时间比较长
    
18.volatile 轻量级锁
    保证可见性和有序性，与锁不同的是， 锁保证原子性和排他性，而volatile只保证原子性，但是volatile
    不会引起上下文切换， 所以被称为轻量级锁。
    
  作用：保障有序性，可见性，保障long/double型变量读写的原子性。
  java语言中对long和double类型变量以外任何类型变量写操作都是原子性的。

  对数组元素的读， 写若要保证触发volatile关键字的作用，则可以采用volatile，可以采用AutomicIntegerArray,AutomicLongArray,AutomicReferenceArray

  volatile的开销，volatile的变量读写不会涉及到上下文切换，因此比锁的开销要小，

    锁的开销涉及到：锁的申请，释放，上下文切换，

    但是volatile的开销比普通变量要高一些，
   
 volatile的应用场景：  volatile除了保证数据的读，写操作的原子性(long/double除外)，典型场景还有如下：
  
 19.CAS只保障共享变量更新操作的原子性， 不保障可见性 

  volatile只保证可见性， 不保证原子性。
  
20，原子操作工具，原子变量类 Atomics
  atomic是基于CAS实现的能保证对共享变量进行 reader-modify-writer更新操作的原子性和可见性的
  一组工具，
  原子变量类相当于基于CAS实现的增强型voloatile变量。
  
  原子变量类有12个，如下分类
  
  基础类     AtomicInteger AtomicLong AtomicBoolean
  数组类    AtomicIntegerArray AtomicLongArray AtomicReferenceArray
 字段更新器 AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater
 引用型 AtomicReference AtomicStampedReference AtomicMarkableReference
   
 
21.并发集合


非线程安全对象                               并发集合类                                           共同接口       

ArrayList             CopyOnwriterArrayList   List
HashSet               CopyOnwriterArraySet     set
LinkedList            ConcurrentLinkedQueue   queue
HashMap               ConcurrentHashMap       map
TreeMap               ConcurrentSkipListMap   sortedmap
TreeSet               ConcurrentSkipListSet   sortedSet

  并发集合对象自身就支持对其进行线程安全的遍历操作，应用代码对并发集合对象进行遍历时无需加锁就可以实现遍历操作的线程安全，
并且对并发集合遍历操作和对其进行更新操作时可以由不同的线程并发执行的，从而有利于充分提高系统的并发性。
ConcurrentLinkedQueue 是queue接口的一个线程安全实现类，它相当于linkedlist(也是queue接口的一个实现类)
的线程安全版，可以做为Collections.synchronizedList(new linkedlist())的替代品，Concurrentlinkedqueue内部
访问其共享状态变量(如队首指针和队尾指针)的时候并不借助锁，而是采用cas操作来保障线程安全，因此concurrentlinkedqueue
是非阻塞的，其使用不会导致当前线程被暂停。因此避免的上下文切换。与BlockingQueue的实现类相比，Concurrentlinkedqueue
更适合于更新操作和遍历操作并发场景，比如一个或者多个线程往队列中添加/删除元素，而另外一个或者多个线程对相应队列进行遍历操作.
而blockingqueue实现类（如 arrayBlockingqueue）更适合于多个线程并发更新同一队列的场景。
比如，生产着和消费者。

ArrayBlockingQueue:
public class ArrayBlockingQueue<E>extends AbstractQueue<E>implements BlockingQueue<E>, Serializable
一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 

这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。 

此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性 (fairness) 设置为 true 而构造的队列允许按照 FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。 



22.线程池

为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）和 Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。否则，在手动配置和调整此类时，使用以下指导：

23.BlockingQueue



插入 ：
boolean add(e)     将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException;    
boolean offer(e)   将指定元素插入到此队列的尾部（如果立即可行且不会超出此队列的容量），在成功时返回 true，如果此队列已满，则返回 false。非阻塞方法

移除 :
Future<V> remove()： 获取并移除此队列的头。此方法与 poll 唯一的不同在于：此队列为空时将抛出一个异常;   
Future<V> poll()：  获取并移除表示下一个已完成任务的 Future，如果不存在这样的任务，则返回 null。非阻塞方法，
Future<V> take()：  返回：此队列的头部, 获取并移除表示下一个已完成任务的 Future实例，该实例就是提交相应任务时submit(Callable<V> task)调用的返回值，如果目前不存在这样的任务，则等待，阻塞方法。 

检查: 

E  element() 获取队列的头，但是不移除此队列的头。此方法与 peek 唯一的不同在于：此队列为空时将抛出一个异常; 
E  peek() 获取但不移除此队列的头；如果此队列为空，则返回 null。非阻塞方法

提交任务到线程池，返回任务的执行结果， Future<V>   submit(Callable<v> task) task表示带执行的异步任务， 该方法返回值可以用于获取响应异步任务的处理结果


    

  
  
  
  
  